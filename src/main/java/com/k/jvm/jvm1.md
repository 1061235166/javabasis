-  如何判断对象已经死亡 
    >1.引用计数法
    >>一个对象被引用一次，计数+1，否则-1，为0说明没有被其他对象引用，但是无法解决
    两个对象互相引用的问题
    
    >2.可达性引用法
    >>一个对象被创建后会被GCRoot引用，之后创建的对象也会在这条引用链记录，如果一个对象没有被GCroot所引用，就会被判断已经死亡
-   垃圾收集有哪些算法，各自的特点？
    >1.标记复制
    >>通常用于新生代的回收算法，特点是将内存分为平均大小的两块，对象被创建以后会被放到其中一块上，当回收的时候
    ,会标记不需要回收的对象并复制到另一块内存上，然后将之前存放对象的内存区域全部回收。好处是不会产生太多的内存碎片      
    
    >2.标记清除
    >>特点是标记可回收的区块，然后回收这些区块的内存
    缺点是效率问题和产生比较多的碎片问题
    
    >3.标记整理
    >>针对老年代的回收算法，和标记清除算法一样，但是之后不会回收内存，而是
    把可存活的对象往一端移动，然后把另一端的内存都回收掉
    
    >4.为什么要新生代和老年代要有不同的回收算法
    >>新生代的对象都是朝生夕死，回收动作频繁，用标记复制算法不会产生太多碎片，老年代对象大，回收次数少，可以用标记整理或者标记清除算法
    
-   垃圾收集器种类
    
    >1.serial收集器
    >>串行收集器，特点是单线程，简单高效。并且工作的时候会暂停用户线程（stop the world），对于新生代来说，他采用标记复制算法进行清理，对于老年代老说，采用标记清除算法工作
    。可以用在新生代和老年代
    
    >2.parallel
    >>并行收集器，就是多线程版本的串行收集器，特点和串行都一样。可以用在新生代和老年代
    
    >>>并行，串行，并发的区别
    >>>>串行是用户线程必须停止才能执行垃圾回收操作，并行也是用户线程必须停止才能执行回收操作
    但是是多个线程进行回收操作。并发是用户线程和垃圾回收线程交替操作，不会暂停用户线程
    
    >3.Parallel Scavenge收集器
    >>新生代的收集器，采用并行的多线程工作，使用标记复制算法。
    关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值
    
    >4.Serial Old收集器
    >>一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。
    
    >5.Parallel Old收集器
    >>使用多线程的标记整理算法
    
    >6.CMS收集器concurrent mark sweep并发清除
    >>是一种以最短停顿时间为特点的收集器，比较适合注重用户体验的项目上
    
    >7.G1 (Garbage-First)收集器
    >>
