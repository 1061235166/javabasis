-  如何判断对象已经死亡 
    >1.引用计数法
    >>一个对象被引用一次，计数+1，否则-1，为0说明没有被其他对象引用，但是无法解决
    两个对象互相引用的问题
    
    >2.可达性引用法
    >>一个对象被创建后会被GCRoot引用，之后创建的对象也会在这条引用链记录，如果一个对象没有被GCroot所引用，就会被判断已经死亡
-   垃圾收集有哪些算法，各自的特点？
    >1.标记复制
    >>通常用于新生代的回收算法，特点是将内存分为平均大小的两块，对象被创建以后会被放到其中一块上，当回收的时候
    ,会标记不需要回收的对象并复制到另一块内存上，然后将之前存放对象的内存区域全部回收。好处是不会产生太多的内存碎片      
    
    >2.标记清除
    >>特点是标记可回收的区块，然后回收这些区块的内存
    缺点是效率问题和产生比较多的碎片问题
    
    >3.标记整理
    >>针对老年代的回收算法，和标记清除算法一样，但是之后不会回收内存，而是
    把可存活的对象往一端移动，然后把另一端的内存都回收掉
    
    >4.为什么要新生代和老年代要有不同的回收算法
    >>新生代的对象都是朝生夕死，回收动作频繁，用标记复制算法不会产生太多碎片，老年代对象大，回收次数少，可以用标记整理或者标记清除算法
    
-   垃圾收集器种类
    
    >1.serial收集器
    >>串行收集器，特点是单线程，简单高效。并且工作的时候会暂停用户线程（stop the world），对于新生代来说，他采用标记复制算法进行清理，对于老年代老说，采用标记清除算法工作
    。可以用在新生代和老年代
    
    >2.parallel
    >>并行收集器，就是多线程版本的串行收集器，特点和串行都一样。可以用在新生代和老年代
    
    >>>并行，串行，并发的区别
    >>>>串行是用户线程必须停止才能执行垃圾回收操作，并行也是用户线程必须停止才能执行回收操作
    但是是多个线程进行回收操作。并发是用户线程和垃圾回收线程交替操作，不会暂停用户线程
    
    >3.Parallel Scavenge收集器
    >>新生代的收集器，采用并行的多线程工作，使用标记复制算法。
    关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值
    
    >4.Serial Old收集器
    >>一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。
    
    >5.Parallel Old收集器
    >>使用多线程的标记整理算法
    
    >6.CMS收集器concurrent mark sweep并发清除
    >>是一种以最短停顿时间为特点的收集器，比较适合注重用户体验的项目上
    
    >7.G1 (Garbage-First)收集器
    >>比较新的一种收集器
-   内存模型的8种操作,保证了原子性和不可分割性
    >lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
     
    > unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
     
    > read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
     
    > load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
     
    > use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
     
    > assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
     
    > store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
     
    > write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
    
-   java内存模型作用
 
    >Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：
    
-   一些常见的java命令,一般都存在于%JAVA_HOME%里,linux或windows都可以直接用,这些命令
    在linux必须要root权限才能正常使用
    >jps(Java Virtual Machine Process Status Tool)
    >>java虚拟机进程状态工具
    
    >jstack
    >>Prints Java thread stack traces for a Java process, core file, or remote debug
    ,打印java进程,核心文件或者远程debug的线程堆栈信息,通常可以追踪到线程信息
    
    >jmap (java memory Map)
    >>java内存映射,一般和jhat使用
    
    >jstat（JVM统计监测工具）
    >>todo
>什么时候执行gc
>>首先在eden区内分配内存空间不足的时候,会触发minoGC,