- 什么是快速失败，什么是安全失败
>fail-fast,快速失败是指在迭代过程中如果发现集合被改动过，直接抛出异常，防止拿到脏数据
>fail-safe，安全失败，在迭代前获取迭代器的副本，对副本进行迭代，不会遇到异常

- javabean是什么
>javabean满足三个条件，1无参构造，2所有字段都是private，方法都是标准getset，3实现serializable接口
>

- 数据库事务隔离级别
>脏读，一个事务的修改并未提交，第二个事务就读取了该事务的信息
>丢失读取，一个事务的修改了数据，第二个事务也修改了数据，导致第一个事务修改丢失
>不可重复读，一个事务多次读取数据，第二个事务在第一个事务多次读取中间修改了数据导致第一个事务两次读取的数据不一样
>幻读，第一个事务读取了一些数据，第二个事务插入了一些数据，导致第一个事务读取到了不存在的数据


- 数据库三范式
>
>
>

- 事务ACID
>atomic原子性，不可分割的操作，一起成功或者一起失败
>consistence一致性，数据一致，比如银行转账，一方转出50另一方就要收到50，总体数量不变
>isolution隔离性，事务和事务之前不会互相影响
>durance持久性，成功之后永久保存在设备上

- hash冲突的解决方式
>链表，线性探测（再哈希（用别的hash函数哈希，直到没有冲突位置），开放地址（从冲突位置向左或者向右一位一位查找，直到找到合适的槽位））

-spring事务的传播方式

- 缓存穿透
>缓存层不命中，储存层不命中，解决方法存放空对象，用布隆过滤器

- 缓存雪崩
>缓存失效导致大量请求访问储存层，导致系统宕机

- synchronized实现原理
>线程进入，查看对象头markword里锁标志是否为1，否的话将其改为1，锁升级为偏向锁，同时会把线程id记录在markword里，如果当前对象无锁，当前线程会在栈帧中建立一个lock_record记录，jvm会使用cas方式更新对象markword
为当前线程的lock_record，如果还是更新失败，会升级为重量级锁

- spring启动流程和请求流程相关，这篇文章不错
> 启动流程，执行main方法，因为springbootconfigration注解里自带enableautoconfigration，而这个注解带有的import注解会从meta/info下的spring.factory文件初始化所有自动配置的组件，同样也会初始化
内嵌tomcat，初始化自动配置文件后，容器会初始化spring相关的组件，包括监听器，上下文，用户的类等
>请求流程：dispathcherservlet接受到请求后执行service方法，handlermapping会将请求转化为handler，handleradpator会执行handler，处理完后返回一个view给viewresovler，resovler会处理
处理返回结果，处理完后结果返回给dispathcherservlet，最后渲染给用户
>https://www.cnblogs.com/theRhyme/p/11057233.html


